package com.cwh.design.abstractfactory;
/**
 *一个系统要独立于它的产品的创建、组合和表示时
 *一个系统要由多个产品系列中的一个来配置时
 *当你要强调一系列相关的产品对象的设计以便进行联合使用时
 *当你提供一个产品类库，而只想显示它们的接口而不是实现时
 *基于简单工厂的横向扩展
 * @author  cwh
  ___                  _
/\  _ `\   _       _  /\ \                       
\ \ \/\_\ /\ \    /\ \\ \ \___        
 \ \ \/_/_\ \ \  _\ \ \\ \  _ `\  
  \ \ \L\ \\ \ \/ _` \ \\ \ \ \ \ 
   \ \____/ \ \_ /_ \_ / \ \_\ \_\
    \/___/   \/_/  \/_/   \/_/\/_/
 *
 *我认为不能说简单工厂模式”对于增加新的产品，无能为力“，因为如果简单工厂是用来生产”东西“的，
 *那任何”东西“的子类，比如汽车，自行车，轮船，洗发水都是可以被生产的，但此处简单工厂的压力太大了啊，
 *任何”东西“的子类都可以被生产，负担太重，所以一般对简单工厂类也有种称呼，叫”上帝类“。
 *而工厂方法模式就很好的减轻了工厂类的负担，把某一类/某一种东西交由一个工厂生产，同时增加某一类”东西“并不需要修改工厂类，
 *只需要添加生产这类”东西“的工厂即可，使得工厂类符合开放-封闭原则。
 *对于”东西“的分类，有时候不能光是横向的分类，从另一个角度也是可以分类的，不知道这句话的意思能不能懂，
 *打个比方：汽车可以根据品牌分为奔驰、奥迪，也可以根据类别分为普通三厢车和SUV车，如果用工厂方法来描述的话，
 *奔驰车工厂有一个方法即生产奔驰车，奥迪车工厂有一个方法生产奥迪车，但在有多重分类的情形下，
 *这样写已经不够用，不符合实际了，这个时候需要用到抽象工厂模式，即奥迪车工厂有两个方法，
 *一个方法是生产普通三厢奥迪车，另一个方法是生产SUV奥迪车。
 *奔驰车工厂有两个方法，一个方法是生产普通三厢奔驰车，另一个方法是生产SUV奔驰车。
 *上面即工厂方法模式和抽象工厂模式的应用场景，因为这两者很像，所以概念上不容易区分，
 *可以这么说，工厂方法模式是一种极端情况的抽象工厂模式，而抽象工厂模式可以看成是工厂方法模式的一种推广。
 *再说下抽象工厂模式，此处的抽象工厂接口应该是有两个方法，一个是生成普通三厢车，一个是生产SUV车，
 *可以说，生产的”东西“已经被限定住了，因此你不能生产某品牌汽车外的其他”东西“，
 *因而可以理解成使用抽象工厂模式不能新增新的”东西“（在简单工厂和工厂方法中理论上都是可以新增任意”东西“的）
 *
 */
public class Test {

	public static void main(String []args){
		IAnimalFactory blackAnimalFactory = new BlackAnimalFactory();
	    ICat blackCat = blackAnimalFactory.creatCat();
	    blackCat.eat();
	    IDog blackDog = blackAnimalFactory.creatDog();
	    blackDog.eat();
	    
	    IAnimalFactory whiteAnimalFactory = new WhiteAnimalFactory();
	    ICat whiteCat = whiteAnimalFactory.creatCat();
	    whiteCat.eat();
	    IDog whiteDog = whiteAnimalFactory.creatDog();
	    whiteDog.eat();
	}
}
